<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript-1：关于类型，有哪些你不知道的细节？ | 前端队长</title>
    <meta name="description" content="前端，JavaScript，Vue">
    <link rel="preload stylesheet" href="/fe-series-notes/assets/style.dfc3b109.css" as="style">
    <script type="module" src="/fe-series-notes/assets/app.e5b5b4d5.js"></script>
    <link rel="preload" href="/fe-series-notes/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
  <link rel="modulepreload" href="/fe-series-notes/assets/chunks/framework.ff44d2fd.js">
  <link rel="modulepreload" href="/fe-series-notes/assets/chunks/theme.aab557fa.js">
  <link rel="modulepreload" href="/fe-series-notes/assets/重学前端_JavaScript篇.md.75870a2c.lean.js">
  <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-99cf8a88><!--[--><!--]--><!--[--><span tabindex="-1" data-v-ae3e3f51></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-ae3e3f51> Skip to content </a><!--]--><!----><header class="VPNav" data-v-99cf8a88 data-v-7e5bc4a5><div class="VPNavBar" data-v-7e5bc4a5 data-v-381568bf><div class="container" data-v-381568bf><div class="title" data-v-381568bf><div class="VPNavBarTitle" data-v-381568bf data-v-305adf00><a class="title" href="/fe-series-notes/" data-v-305adf00><!--[--><!--]--><!--[--><img class="VPImage logo" src="/fe-series-notes/logo.jpg" alt data-v-6db2186b><!--]--><!--[-->前端队长の博客<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-381568bf><div class="curtain" data-v-381568bf></div><div class="content-body" data-v-381568bf><!--[--><!--]--><div class="VPNavBarSearch search" style="--vp-meta-key:&#39;Meta&#39;;" data-v-381568bf><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg class="DocSearch-Search-Icon" width="20" height="20" viewBox="0 0 20 20" aria-label="search icon"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-381568bf data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> 前端工程化 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/fe-series-notes/engineer/" data-v-2f2cfafc><!--[-->从零搭建Vue3项目<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/fe-series-notes/engineer/vue3-cli/" data-v-2f2cfafc><!--[-->前端脚手架CLI<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/fe-series-notes/engineer/cicd/" data-v-2f2cfafc><!--[-->前端构建部署<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/fe-series-notes/engineer/monitor/" data-v-2f2cfafc><!--[-->前端监控<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/fe-series-notes/性能优化/" tabindex="0" data-v-7f418b0f data-v-5e623618><!--[-->前端性能优化<!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/fe-series-notes/浏览器工作原理/" tabindex="0" data-v-7f418b0f data-v-5e623618><!--[-->浏览器工作原理<!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/fe-series-notes/webpack通关秘籍/" tabindex="0" data-v-7f418b0f data-v-5e623618><!--[-->webpack通关秘籍<!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> vue原理剖析 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/fe-series-notes/vue2原理剖析/" data-v-2f2cfafc><!--[-->vue2原理剖析<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> TEST <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link vp-external-link-icon" href="https://vitepress.dev/guide/markdown" target="_blank" rel="noreferrer" data-v-2f2cfafc><!--[-->Markdown Extensions<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-381568bf data-v-f6a63727><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-f6a63727 data-v-82b282f1 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-82b282f1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-82b282f1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-381568bf data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink" href="https://github.com/daotin" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-36371990><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-381568bf data-v-40855f84 data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-764effdf><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-764effdf><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>Appearance</p><div class="appearance-action" data-v-40855f84><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-40855f84 data-v-82b282f1 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-82b282f1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-82b282f1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-40855f84><div class="item social-links" data-v-40855f84><div class="VPSocialLinks social-links-list" data-v-40855f84 data-v-7bc22406><!--[--><a class="VPSocialLink" href="https://github.com/daotin" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-36371990><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-381568bf data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-99cf8a88 data-v-97b5189c><div class="VPDoc has-aside" data-v-97b5189c data-v-e9631fd0><!--[--><!--]--><div class="container" data-v-e9631fd0><div class="aside" data-v-e9631fd0><div class="aside-curtain" data-v-e9631fd0></div><div class="aside-container" data-v-e9631fd0><div class="aside-content" data-v-e9631fd0><div class="VPDocAside" data-v-e9631fd0 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-3f215769 data-v-ff0f39c8><div class="content" data-v-ff0f39c8><div class="outline-marker" data-v-ff0f39c8></div><div class="outline-title" data-v-ff0f39c8>TOC</div><nav aria-labelledby="doc-outline-aria-label" data-v-ff0f39c8><span class="visually-hidden" id="doc-outline-aria-label" data-v-ff0f39c8> Table of Contents for current page </span><ul class="root" data-v-ff0f39c8 data-v-b0ff2abe><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-e9631fd0><div class="content-container" data-v-e9631fd0><!--[--><!--]--><!----><main class="main" data-v-e9631fd0><div style="position:relative;" class="vp-doc _fe-series-notes_%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF_JavaScript%E7%AF%87" data-v-e9631fd0><div><h1 id="javascript-1-关于类型-有哪些你不知道的细节" tabindex="-1">JavaScript-1：关于类型，有哪些你不知道的细节？ <a class="header-anchor" href="#javascript-1-关于类型-有哪些你不知道的细节" aria-label="Permalink to &quot;JavaScript-1：关于类型，有哪些你不知道的细节？&quot;">​</a></h1><h2 id="关于类型-有哪些你不知道的细节" tabindex="-1">关于类型，有哪些你不知道的细节？ <a class="header-anchor" href="#关于类型-有哪些你不知道的细节" aria-label="Permalink to &quot;关于类型，有哪些你不知道的细节？&quot;">​</a></h2><p>根据最新的语言标准，JavaScript有7种语言类型：</p><ol><li>Undefined；</li><li>Null；</li><li>Boolean；</li><li>String；</li><li>Number；</li><li>Symbol（ES6新加入）；</li><li>Object。</li></ol><h3 id="为什么有的编程规范要求用-void-0-代替-undefined" tabindex="-1">为什么有的编程规范要求用 void 0 代替 undefined？ <a class="header-anchor" href="#为什么有的编程规范要求用-void-0-代替-undefined" aria-label="Permalink to &quot;为什么有的编程规范要求用 void 0 代替 undefined？&quot;">​</a></h3><p>Undefined类型的值只有一个 undefined。</p><p>任何一个变量未赋值前值都为 undefined，一般我们使用全局变量 undefined 表示，但是由于 undefined 是个变量，是可以被修改的，所以我们一般使用 <code>void 0</code> 的返回值（<strong>void 运算符</strong> 可以对给定的表达式进行求值，然后返回 <code>undefined</code>）来代替 undefined 变量。</p><blockquote><p>PS：根据ES5的规范，在现代浏览器中，全局的undefined的值将不可修改。但是在局部环境是可以被赋值的！！</p></blockquote><p>Null类型的值只有一个 null，表示一个变量定义了但是为空。</p><p>所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。</p><p>还有null是关键字，而不是变量，可以放心使用。</p><h3 id="字符串是否有最大长度" tabindex="-1">字符串是否有最大长度？ <a class="header-anchor" href="#字符串是否有最大长度" aria-label="Permalink to &quot;字符串是否有最大长度？&quot;">​</a></h3><p>String 有最大长度是 <code>2^53 - 1</code>，但是这个所谓最大长度，并不完全是你理解中的字符数。</p><p>因为 JavaScript 中的String类型存储的方式是 <code>UTF16</code>格式的，所以 String 的最大长度指的是保存为UTF16格式时候的最大程度，转化成 字符数的话肯定不到一半长度。。但是肯定够日常使用了。</p><h3 id="为什么在-javascript-中-0-1-0-2-不能-0-3" tabindex="-1">为什么在 JavaScript 中，0.1+0.2 不能 =0.3？ <a class="header-anchor" href="#为什么在-javascript-中-0-1-0-2-不能-0-3" aria-label="Permalink to &quot;为什么在 JavaScript 中，0.1+0.2 不能 =0.3？&quot;">​</a></h3><p>答：计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失，当这些丢失精度的二进制转换成十进制就造成上面的错误了。</p><blockquote><p>另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。</p></blockquote><p><strong>浮点数的比较</strong></p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">( </span><span style="color:#79B8FF;">0.1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0.2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0.3</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// false</span></span></code></pre></div><p>上面的代码输出的结果是 false，说明两边不相等的。</p><p>这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。</p><p>所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">( Math.</span><span style="color:#B392F0;">abs</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0.1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0.2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0.3</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> Number.EPSILON); </span><span style="color:#6A737D;">// true</span></span></code></pre></div><p>检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。</p><h3 id="什么是symbol类型" tabindex="-1">什么是Symbol类型？ <a class="header-anchor" href="#什么是symbol类型" aria-label="Permalink to &quot;什么是Symbol类型？&quot;">​</a></h3><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">();</span></span></code></pre></div><p>上面代码中，变量s就是一个独一无二的值，像一个独一无二的字符串，但是又不是一个字符串类型。</p><p>typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p><blockquote><p>注意：Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p></blockquote><p>Symbol函数可以接受一个字符串作为参数，表示<strong>对 Symbol 实例的描述</strong>，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;bar&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">s1 </span><span style="color:#6A737D;">// Symbol(foo)</span></span>
<span class="line"><span style="color:#E1E4E8;">s2 </span><span style="color:#6A737D;">// Symbol(bar)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">s1.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// &quot;Symbol(foo)&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">s2.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// &quot;Symbol(bar)&quot;</span></span></code></pre></div><p>上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">obj</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;abc&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">sym</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8;">sym </span><span style="color:#6A737D;">// Symbol(abc)</span></span></code></pre></div><blockquote><p><strong>注意</strong>，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的（虽然描述看起来是相同的）。</p></blockquote><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;aaa&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;aaa&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(s,s1,s</span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;">s1); </span><span style="color:#6A737D;">// Symbol(aaa) Symbol(aaa) false</span></span></code></pre></div><p>以上参考链接：<a href="https://www.cnblogs.com/sunshineForFuture/p/10432440.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/sunshineForFuture/p/10432440.html</a></p><h3 id="为什么给对象添加的方法能用在基本类型上" tabindex="-1">为什么给对象添加的方法能用在基本类型上？ <a class="header-anchor" href="#为什么给对象添加的方法能用在基本类型上" aria-label="Permalink to &quot;为什么给对象添加的方法能用在基本类型上？&quot;">​</a></h3><p>JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”（你看他们长得一模一样）。它们是：</p><ul><li>Number；</li><li>String；</li><li>Boolean；</li><li>Symbol。</li></ul><p>所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。</p><p>Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。</p><p>Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。</p><p>回答上面的问题，为什么给对象添加的方法能用在基本类型上？</p><p>答案就是，<strong>运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。</strong></p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> num </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">123</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(num.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">//  num被悄悄转换成临时对象 new Number(123)</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;abc&quot;</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">charAt</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)); </span><span style="color:#6A737D;">// &#39;abc&#39; 字符串被悄悄转换成临时对象 new String(&#39;abc&#39;)</span></span></code></pre></div><h3 id="装箱转换和拆箱转换" tabindex="-1">装箱转换和拆箱转换 <a class="header-anchor" href="#装箱转换和拆箱转换" aria-label="Permalink to &quot;装箱转换和拆箱转换&quot;">​</a></h3><p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象。</p><p>前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> symbolObject </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(){ </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">; }).</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> symbolObject); </span><span style="color:#6A737D;">//object</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(symbolObject </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">//true</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(symbolObject.</span><span style="color:#79B8FF;">constructor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Symbol); </span><span style="color:#6A737D;">//true</span></span></code></pre></div><p>我们定义一个函数，函数里面只有 return this，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 symbolObject。</p><p>我们可以用 console.log 看一下这个东西的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象。</p><p>装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。</p><p>使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> symbolObject </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> symbolObject); </span><span style="color:#6A737D;">//object</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(symbolObject </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">//true</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(symbolObject.</span><span style="color:#79B8FF;">constructor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Symbol); </span><span style="color:#6A737D;">//true</span></span></code></pre></div><p>每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> symbolObject </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">Object</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.toString.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(symbolObject)); </span><span style="color:#6A737D;">//[object Symbol]</span></span></code></pre></div><p>在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。</p><p><strong>拆箱转换</strong>，就是把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。</p><p>拆箱转换会尝试调用 <code>valueOf</code> 和<code> toString</code> 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p><p>如下面的例子：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">valueOf</span><span style="color:#E1E4E8;"> : () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;valueOf&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {}},</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;"> : () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;toString&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {}}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">o </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#6A737D;">// valueOf</span></span>
<span class="line"><span style="color:#6A737D;">// toString</span></span>
<span class="line"><span style="color:#6A737D;">// TypeError</span></span></code></pre></div><p>我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o*2 这个运算的时候（一个对象乘以2，那么js会想把o转换成Number基本类型，会调用valueOf，并期望返回一个基本类型，但是返回的却是一个对象。。），你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。</p><p>如果将valueOf的返回值改为任意基本类型就会拆箱成功，如：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">valueOf</span><span style="color:#E1E4E8;"> : () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;valueOf&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">},</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;"> : () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;toString&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {}}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>valueOf，和toString的执行顺序默认是valueOf先，然后是toString。</p></blockquote><h3 id="typeof-类型判断准确吗" tabindex="-1">typeof 类型判断准确吗？ <a class="header-anchor" href="#typeof-类型判断准确吗" aria-label="Permalink to &quot;typeof 类型判断准确吗？&quot;">​</a></h3><p>事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JavaScript 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。</p><p><img src="/fe-series-notes/assets/img-20240508140582.011897ae.png" alt=""></p><p>在表格中，多数项是对应的，但是请注意 object——Null 和 function——Object 是特例，我们理解类型的时候需要特别注意这个区别。</p><h1 id="javascript-2-面向对象-vs-javascript中的面向对象" tabindex="-1">JavaScript-2：面向对象 vs JavaScript中的面向对象 <a class="header-anchor" href="#javascript-2-面向对象-vs-javascript中的面向对象" aria-label="Permalink to &quot;JavaScript-2：面向对象 vs JavaScript中的面向对象&quot;">​</a></h1><p>对象的特征如下：</p><ul><li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li><li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li><li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</li></ul><p>JavaScript 中对象独有的特色是：<strong>对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</strong> 如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。</p><h2 id="javascript-对象的两类属性" tabindex="-1">JavaScript 对象的两类属性 <a class="header-anchor" href="#javascript-对象的两类属性" aria-label="Permalink to &quot;JavaScript 对象的两类属性&quot;">​</a></h2><p>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。</p><p>属性又分为：<strong>数据属性和访问器(getter/setter)属性</strong>。</p><h3 id="数据属性" tabindex="-1">数据属性 <a class="header-anchor" href="#数据属性" aria-label="Permalink to &quot;数据属性&quot;">​</a></h3><p>数据属性具有4个特征：</p><ul><li><code>value</code>：就是属性的值。</li><li><code>writable</code>：决定属性能否被赋值。</li><li><code>enumerable</code>：决定 for in 能否枚举该属性。</li><li><code>configurable</code>：决定该属性能否被删除或者改变特征值。</li></ul><p>在大多数情况下，我们只关心数据属性的值即可。</p><h3 id="访问器-getter-setter-属性" tabindex="-1">访问器(getter/setter)属性 <a class="header-anchor" href="#访问器-getter-setter-属性" aria-label="Permalink to &quot;访问器(getter/setter)属性&quot;">​</a></h3><p>访问器(getter/setter)属性也具有4个特征：</p><ul><li><code>getter</code>：函数或 undefined，在取属性值时被调用。</li><li><code>setter</code>：函数或 undefined，在设置属性值时被调用。</li><li><code>enumerable</code>：决定 for in 能否枚举该属性。</li><li><code>configurable</code>：决定该属性能否被删除或者改变特征值。</li></ul><p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p><p>我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。</p><p>我们可以使用内置函数 <code>Object.getOwnPropertyDescripter</code> 来查看，如以下代码所示：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { a: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> };</span></span>
<span class="line"><span style="color:#E1E4E8;">o.b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">//a 和 b 皆为数据属性</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">getOwnPropertyDescriptor</span><span style="color:#E1E4E8;">(o,</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// {value: 1, writable: true, enumerable: true, configurable: true}</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">getOwnPropertyDescriptor</span><span style="color:#E1E4E8;">(o,</span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// {value: 2, writable: true, enumerable: true, configurable: true}</span></span></code></pre></div><p>如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 <code>Object.defineProperty</code>，示例如下：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { a: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> };</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">defineProperty</span><span style="color:#E1E4E8;">(o, </span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#E1E4E8;">, {value: </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, writable: </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, enumerable: </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, configurable: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#6A737D;">//a和b都是数据属性，但特征值变化了</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">getOwnPropertyDescriptor</span><span style="color:#E1E4E8;">(o,</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// {value: 1, writable: true, enumerable: true, configurable: true}</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">getOwnPropertyDescriptor</span><span style="color:#E1E4E8;">(o,</span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// {value: 2, writable: false, enumerable: false, configurable: true}</span></span>
<span class="line"><span style="color:#E1E4E8;">o.b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(o.b); </span><span style="color:#6A737D;">// 2</span></span></code></pre></div><p>在创建对象时，也可以使用 <code>get</code> 和 <code>set</code> 关键字来创建访问器属性，代码如下所示：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">get</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">a</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;getter&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">set</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">a</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">val</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;setter&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> val;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">o.a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">123</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(o.a); </span><span style="color:#6A737D;">// setter getter 123</span></span></code></pre></div><p>实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以<strong>字符串或者 Symbol</strong> 为 key，以<strong>数据属性特征值或者访问器属性特征值</strong>为 value。</p><p>比如上面 a 为对象o的key，访问器属性或者<code>{writable:true,value:1,configurable:true,enumerable:true}</code> 为value。</p><p>到这里，可以理解有人得出 “JavaScript 不是面向对象” 的说法， 但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式，所以它也是正统的面向对象语言。</p><p>JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。</p><h1 id="javascript-3-js需要模拟类吗" tabindex="-1">JavaScript-3：JS需要模拟类吗？ <a class="header-anchor" href="#javascript-3-js需要模拟类吗" aria-label="Permalink to &quot;JavaScript-3：JS需要模拟类吗？&quot;">​</a></h1><p>JavaScript 本身就是面向对象的，它并不需要模拟，只是它实现面向对象的方式和主流的流派不太一样，所以才会出现将JavaScript模拟类的操作。</p><p>从 ES6 开始，JavaScript 提供了 <code>class</code>关键字来定义类，尽管，这样的方案仍然是<strong>基于原型运行时系统的模拟</strong>，但是它修正了之前的一些常见的“坑”，统一了社区的方案，这对语言的发展有着非常大的好处。</p><p>其实当初 Brendan 当年选择的<strong>原型系统</strong>，就是一个非常优秀的抽象对象的形式。</p><h2 id="javascript原型" tabindex="-1">JavaScript原型 <a class="header-anchor" href="#javascript原型" aria-label="Permalink to &quot;JavaScript原型&quot;">​</a></h2><p>可以用两条进行概括：</p><ul><li>如果所有对象都有私有字段 <code>[[prototype]]</code>，就是对象的原型；</li><li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</li></ul><p>ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。</p><p>三个方法分别为：</p><ul><li><code>Object.create</code> 根据指定的原型创建新对象，原型可以是 null；</li><li><code>Object.getPrototypeOf</code> 获得一个对象的原型；</li><li><code>Object.setPrototypeOf</code> 设置一个对象的原型。</li></ul><hr><p>后续补充，太难了。。。😭</p></div></div></main><footer class="VPDocFooter" data-v-e9631fd0 data-v-face870a><!--[--><!--]--><div class="edit-info" data-v-face870a><div class="edit-link" data-v-face870a><a class="VPLink link edit-link-button" href="https://github.com/Daotin/blog/edit/main/docs/重学前端/JavaScript篇.md" target="_blank" rel="noreferrer" data-v-face870a><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" aria-label="edit icon" data-v-face870a><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> Edit this page on GitHub<!--]--></a></div><div class="last-updated" data-v-face870a><p class="VPLastUpdated" data-v-face870a data-v-149a99df>Last updated: <time datetime="2024-05-08T07:42:31.000Z" data-v-149a99df></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter" data-v-99cf8a88 data-v-f4388a15><div class="container" data-v-f4388a15><p class="message" data-v-f4388a15>Released under the CC BY-NC-ND 3.0</p><p class="copyright" data-v-f4388a15>Copyright © 2022-present Daotin</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"10x程序员工作法_index.md\":\"a865d5cf\",\"前端进阶训练营_index.md\":\"55a5e56a\",\"engineer_vue3-component_login.md\":\"e22c80c6\",\"engineer_cicd_index.md\":\"3570278b\",\"engineer_cicd_docker从入门到实践.md\":\"19a47da8\",\"engineer_vue3-template_element-plus.md\":\"1f288861\",\"engineer_vue3-template_format.md\":\"f4d6f574\",\"engineer_vue3-template_pinia.md\":\"f4d4f0f3\",\"engineer_vue3-template_structure.md\":\"8140332c\",\"engineer_vue3-template_vite-config.md\":\"88de706c\",\"vue2原理剖析_疑问.md\":\"d66b47bb\",\"engineer_vue3-template_mock.md\":\"d025105f\",\"vue2原理剖析_readme.md\":\"cb65f9ee\",\"typescript通关秘籍_index.md\":\"9211847d\",\"index.md\":\"89e49201\",\"vue2原理剖析_vue事件机制.md\":\"e2ebd214\",\"engineer_vue3-template_vue-router.md\":\"b8dfc7f3\",\"vue2原理剖析_模版渲染_template如何转换成渲染函数的？.md\":\"48e67bd9\",\"vue2原理剖析_响应式系统_readme.md\":\"0f0bc09e\",\"vue2原理剖析_index.md\":\"3281a490\",\"vue2原理剖析_模版渲染_vnode的patch过程.md\":\"4e11ec63\",\"engineer_vue3-template_tailwind.md\":\"00f34fc0\",\"vue2原理剖析_模版渲染_渲染函数如何转换成vnode节点？.md\":\"634c2680\",\"vue2组件精讲_index.md\":\"007c8913\",\"vue2原理剖析_异步更新策略和nexttick原理.md\":\"da461b8a\",\"vue2组件精讲_01.md\":\"33758ed9\",\"webpack通关秘籍_webpack打包速度和体积优化.md\":\"f05d5d52\",\"webpack通关秘籍_index.md\":\"11a5cbb6\",\"engineer_index.md\":\"9d369c91\",\"engineer_monitor_index.md\":\"d84dc7d4\",\"webpack通关秘籍_学什么.md\":\"3c833613\",\"engineer_cicd_cicd从入门到实践.md\":\"4df69abb\",\"engineer_vue3-cli_index.md\":\"62bb2e98\",\"engineer_cicd_nginx从入门到实践.md\":\"30cdb083\",\"engineer_vue3-component_优先使用webp图片.md\":\"f1e3f206\",\"engineer_vue3-component_svg预览组件.md\":\"fc1ad97d\",\"engineer_vue3-template_assets.md\":\"6f13c44a\",\"engineer_monitor_sentry入门与实践.md\":\"9b3cdef8\",\"engineer_vue3-template_create-project.md\":\"b73b927b\",\"engineer_vue3-template_environment.md\":\"02774138\",\"webpack通关秘籍_webpack编写loader和plugin.md\":\"7a9c3034\",\"webpack通关秘籍_vue-cli默认构建配置优化.md\":\"759be9ee\",\"engineer_vue3-template_layouts.md\":\"aed08413\",\"webpack通关秘籍_webpack常用配置.md\":\"6e5a7913\",\"10x程序员工作法_10x程序员工作法.md\":\"f3222036\",\"左耳听风_时间管理.md\":\"a8e9f36a\",\"左耳听风_职业发展.md\":\"b72604ed\",\"性能优化_chrome-devtools-performance.md\":\"43ab0f08\",\"浏览器工作原理_v8工作原理.md\":\"411a1056\",\"浏览器工作原理_index.md\":\"172e83c2\",\"浏览器工作原理_事件循环.md\":\"f9317f65\",\"浏览器工作原理_学什么？.md\":\"1e8c8094\",\"浏览器工作原理_已归档_01-chrome浏览器架构.md\":\"dcd44393\",\"浏览器工作原理_已归档_02-tcp协议：如何保证页面文件能被完整送达浏览器？.md\":\"401afe8d\",\"浏览器工作原理_已归档_03-http请求流程：为什么很多站点第二次打开速度会很快？.md\":\"a27301fc\",\"浏览器工作原理_已归档_05-渲染流程（上）：html、css和javascript，是如何变成页面的？.md\":\"07475284\",\"浏览器工作原理_已归档_04-导航流程：从输入url到页面展示，这中间发生了什么？.md\":\"da5c57cf\",\"浏览器工作原理_已归档_07-变量提升：javascript代码是按顺序执行的吗？.md\":\"89934ab8\",\"浏览器工作原理_已归档_06-渲染流程（下）：html、css和javascript，是如何变成页面的？.md\":\"dcd67d92\",\"浏览器工作原理_已归档_08-调用栈：为什么javascript代码会出现栈溢出？.md\":\"7bec1199\",\"前端进阶训练营_学习安排.md\":\"624392d3\",\"前端进阶训练营_开班直播.md\":\"e18301d5\",\"大厂晋升指南_index.md\":\"290479c8\",\"大厂晋升指南_学习方法.md\":\"598997b5\",\"左耳听风_index.md\":\"775bbdc6\",\"engineer_vue3-template_axios.md\":\"db6a8f32\",\"左耳听风_技术变现.md\":\"a4c83228\",\"左耳听风_技术趋势.md\":\"c0fce21f\",\"浏览器工作原理_已归档_10-作用域链和闭包：代码中出现相同的变量，javascript引擎是如何选择的？.md\":\"d2458fa1\",\"前端进阶训练营_二、重学javascript.md\":\"016847c3\",\"engineer_vue3-template_auth.md\":\"9460e6e8\",\"engineer_vue3-cli_从零开始构建脚手架.md\":\"cc2cb45a\",\"webpack通关秘籍_webpack构建原理.md\":\"af11f41f\",\"左耳听风_技术领导力.md\":\"f07758cf\",\"engineer_vue3-template_develop-tool.md\":\"3da3424e\",\"性能优化_index.md\":\"d71a0717\",\"浏览器工作原理_已归档_14-编译器和解释器：v8是如何执行一段javascript代码的？.md\":\"907ece4d\",\"性能优化_通过timing瀑布图分析前端性能问题.md\":\"3f61791e\",\"浏览器工作原理_已归档_15-消息队列和事件循环：页面是怎么“活”起来的？.md\":\"19d79795\",\"浏览器工作原理_已归档_11-this：从javascript执行上下文的视角讲清楚this.md\":\"bc9af786\",\"性能优化_bluelink项目打包体积优化.md\":\"4eb7df4a\",\"性能优化_关于requestanimationframe的理解.md\":\"04d1dec3\",\"性能优化_前端性能优化.md\":\"845647cc\",\"性能优化_vue2-webpack性能优化.md\":\"dd44f892\",\"浏览器工作原理_已归档_13-垃圾回收：垃圾数据是如何自动回收的？.md\":\"01e20d4b\",\"浏览器工作原理_已归档_21-chrome开发者工具：利用网络面板做性能分析.md\":\"cc24a1a3\",\"浏览器工作原理_已归档_18-宏任务和微任务：不是所有任务都是一个待遇.md\":\"d8b4c92d\",\"浏览器工作原理_已归档_16-webapi：settimeout是如何实现的？.md\":\"fee0365d\",\"浏览器工作原理_已归档_17-webapi：xmlhttprequest是怎么实现的？.md\":\"dd1f03f2\",\"玩转vue3全家桶_index.md\":\"03cd3a59\",\"浏览器工作原理_已归档_20-async↗await：使用同步的方式去写异步代码.md\":\"7cc59bdc\",\"重学前端_index.md\":\"a16a4639\",\"重学前端_javascript篇.md\":\"75870a2c\",\"浏览器工作原理_javascript执行机制.md\":\"148353d2\",\"浏览器工作原理_已归档_19-promise：使用promise，告别回调函数.md\":\"d6130484\",\"浏览器工作原理_浏览器的多进程，页面渲染流程.md\":\"d8ec8bea\",\"玩转vue3全家桶_temp.md\":\"04d82436\",\"重学前端_前端的学习路线与方法.md\":\"e3a950b9\",\"前端进阶训练营_一、浏览器工作原理.md\":\"02035ccf\"}")
__VP_SITE_DATA__ = JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"前端队长\",\"description\":\"前端，JavaScript，Vue\",\"base\":\"/fe-series-notes/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"logo\":\"/logo.jpg\",\"siteTitle\":\"前端队长の博客\",\"search\":{\"provider\":\"local\"},\"lastUpdated\":\"更新日期\",\"smoothScroll\":true,\"nav\":[{\"text\":\"前端工程化\",\"items\":[{\"text\":\"从零搭建Vue3项目\",\"link\":\"/engineer/\"},{\"text\":\"前端脚手架CLI\",\"link\":\"/engineer/vue3-cli/\"},{\"text\":\"前端构建部署\",\"link\":\"/engineer/cicd/\"},{\"text\":\"前端监控\",\"link\":\"/engineer/monitor/\"}]},{\"text\":\"前端性能优化\",\"link\":\"/性能优化/\"},{\"text\":\"浏览器工作原理\",\"link\":\"/浏览器工作原理/\"},{\"text\":\"webpack通关秘籍\",\"link\":\"/webpack通关秘籍/\"},{\"text\":\"vue原理剖析\",\"items\":[{\"text\":\"vue2原理剖析\",\"link\":\"/vue2原理剖析/\"}]},{\"text\":\"TEST\",\"items\":[{\"text\":\"Markdown Extensions\",\"link\":\"https://vitepress.dev/guide/markdown\"}]}],\"sidebar\":{\"/engineer/\":[{\"text\":\"从零搭建Vue3项目\",\"collapsed\":false,\"items\":[{\"text\":\"开发工具推荐\",\"link\":\"/engineer/vue3-template/develop-tool\"},{\"text\":\"创建项目\",\"link\":\"/engineer/vue3-template/create-project\"},{\"text\":\"目录结构\",\"link\":\"/engineer/vue3-template/structure\"},{\"text\":\"vite工程化配置\",\"link\":\"/engineer/vue3-template/vite-config\"},{\"text\":\"代码规范\",\"link\":\"/engineer/vue3-template/format\"},{\"text\":\"git提交规范\",\"link\":\"https://daotin.github.io/posts/2022/08/10/git-commit%E8%A7%84%E8%8C%83.html\"},{\"text\":\"引入ElementPlus组件库\",\"link\":\"/engineer/vue3-template/element-plus\"},{\"text\":\"引入TailWindCSS\",\"link\":\"/engineer/vue3-template/tailwind\"},{\"text\":\"配置vue-router\",\"link\":\"/engineer/vue3-template/vue-router\"},{\"text\":\"配置Pinia\",\"link\":\"/engineer/vue3-template/pinia\"},{\"text\":\"封装axios\",\"link\":\"/engineer/vue3-template/axios\"},{\"text\":\"配置mock\",\"link\":\"/engineer/vue3-template/mock\"},{\"text\":\"静态资源管理\",\"link\":\"/engineer/vue3-template/assets\"},{\"text\":\"界面布局layouts\",\"link\":\"/engineer/vue3-template/layouts\"},{\"text\":\"配置环境变量\",\"link\":\"/engineer/vue3-template/environment\"},{\"text\":\"权限控制\",\"link\":\"/engineer/vue3-template/auth\"}]},{\"text\":\"业务模块\",\"collapsed\":false,\"items\":[{\"text\":\"登录注册\",\"link\":\"/engineer/vue3-component/login\"},{\"text\":\"svg预览组件\",\"link\":\"/engineer/vue3-component/svg预览组件\"},{\"text\":\"优先使用webp图片\",\"link\":\"/engineer/vue3-component/优先使用webp图片\"}]}],\"/engineer/vue3-cli/\":[{\"text\":\"前端脚手架CLI\",\"collapsed\":false,\"items\":[{\"text\":\"从零开始构建脚手架\",\"link\":\"/engineer/vue3-cli/从零开始构建脚手架\"}]}],\"/engineer/cicd/\":[{\"text\":\"前端构建部署\",\"collapsed\":false,\"items\":[{\"text\":\"Nginx从入门到实践\",\"link\":\"/engineer/cicd/Nginx从入门到实践\"},{\"text\":\"Docker从入门到实践\",\"link\":\"/engineer/cicd/Docker从入门到实践\"},{\"text\":\"CICD从入门到实践\",\"link\":\"/engineer/cicd/CICD从入门到实践\"}]}],\"/engineer/monitor/\":[{\"text\":\"前端监控\",\"collapsed\":false,\"items\":[{\"text\":\"Sentry入门与实践\",\"link\":\"/engineer/monitor/Sentry入门与实践\"}]}]},\"outline\":\"deep\",\"outlineTitle\":\"TOC\",\"editLink\":{\"pattern\":\"https://github.com/Daotin/blog/edit/main/docs/:path\",\"text\":\"Edit this page on GitHub\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/daotin\"}],\"footer\":{\"message\":\"Released under the CC BY-NC-ND 3.0\",\"copyright\":\"Copyright © 2022-present Daotin\"}},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}")</script>
    
  </body>
</html>